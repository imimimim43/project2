## 정렬 알고리즘(+퀵정렬)의 성능 분석 및 비교
<ol>
<li>값 정렬 설명</li>
<li>각 알고리즘 설명 및 그래프 분석</li>
</ol>
<br>

각 알고리즘마다 정렬된 배열값, 역순으로 정렬된 배열값, 랜덤으로 정렬된 배열값을 넣어 비교해볼 것이다. 입력개수를 2^20값까지 넣으면 이클립스가 실행되지 않아 2^5 ~ 2^12까지 넣어봤다.

## 코드 구현
 **코드에 쓰일 배열 선언**
 
 ■ 배열 정렬시키는 코드
```
for(int i = 0; i < arr.length; i++) {
				arr[i] = (i+1); 
		}

```
 ■ 배열 역순으로 정렬시키는 코드
```
for(int i = 0; i < arr.length; i++) {
			arr[i] = (arr.length-i*1); 
	}

```
 ■ 값을 랜덤으로 정렬시키는 코드
```
 public static int[] shuffle(int[] arr){
		    for(int x=0;x<arr.length;x++){
		      int i = (int)(Math.random()*arr.length);
		      int j = (int)(Math.random()*arr.length);
		            
		      int tmp = arr[i];
		      arr[i] = arr[j];
		      arr[j] = tmp;
		    }
      
      for(int i = 0; i < arr.length; i++) {
				arr[i] = (i+1); 
				}
	        arr = shuffle(arr);

```

## 버블 정렬(Bublle_Sort)

<br>

## 쉘 정렬(Shell_Sort)
![image](https://user-images.githubusercontent.com/102197100/166885473-207a92c7-0ef2-4dd3-aedb-68aa970263fe.png)
<br>
■ 포드-풀커슨(Ford-Fulkerson)

- 유량 네트워크에서 소스(시작점)와 싱크(끝점)사이에 흐를 수 있는 최대 유량(Maximum Flow)을 구하는 알고리즘이다.

<br>


 ![image](https://user-images.githubusercontent.com/102197100/165531238-c59d5ab5-c3c3-4601-811e-7aabf90a95c5.png)
  
-  (a,c)간선을 예로 들면, 초당 최대 20만큼의 자료를 전송할 수 있으며 이때의 20은 간선의 용량(capacity)라고 한다. <br>
   또한, 초당 13만큼의 자료가 전송되고 있는데 이때의 13은 간선의 유량(flow)라고 한다.<br>
 - 경로 s-b-d-t를 살펴보면, 거치는 간선의 용량의 최솟값은 3이므로 이 값이 해당 경로를 통해 보낼 수 있는 유량의 최댓값이다.<br>

■ 유량 네트워크(flow network)의 속성 
<ol>
<li>용량 제한 속성</li>
  - 모든 간선에 대해 유량은 용량을 초과할 수 없다.
  
<li>유량의 대칭성 </li>
  - f( u, v ) = -f( u, v )
  
<li>유량의 보존</li>
  - 시작점에서 흘려보낸 유량은 모두 끝점에 도착하게 된다.
</ol>
<br>

■  **포드-풀커슨 알고리즘**
- 유량 네트워크의 모든 간선의 유량을 0으로 두고 시작해서, 시작점에서 끝점으로 유량을 더 보낼 수 있는 경로(증가 경로)를 찾아 유량을 추가로 보내기를 반복한다. 이렇게 증가 경로를 찾아서 유량을 추가로 흘려보내다가 증가 경로가 존재하지 않으면 네트워크에 최대 유량이 흐르고 있다고 판단하고 알고리즘은 종료된다.
<br>

- **포드-풀커슨 알고리즘**이란, 다시 간단히 말해서 소스(source) 노드에서 시작해 싱크(sink) 노드로 도착하는 유량이다.
<ol>
<li>유량 네트워크의 모든 간선의 유량을 0으로 초기화.</li>
  
<li>소스에서 싱크로 유량을 더 보낼 수 있는 경로를 찾아 유량 보내기를 반복.</li>
</ol>

![image](https://user-images.githubusercontent.com/102197100/165806071-132388e6-e9e5-402b-8244-7be063d71fda.png)

- 위 사진 속 그래프는 서로 같은 그래프이지만 왼쪽 경로는 최대 유량이 2, 오른쪽 경로는 최대 유량이 1이다. 왼쪽 경로는 오른쪽 경로에서 유량이 1 늘었는데, 유량을 증가시키는 것을 **증가 경로(augmenting path)** 라고 한다. 포드-풀커슨 알고리즘의 목표는 왼쪽 경로와 같이 최대 유량을 찾는 것, 즉 증가 경로를 찾는 것이다.

> 증가 경로로 보낼 수 있는 최대 유량 = 포함된 간선의 잔여 용량 중에서 가장 작은 값.


#### 유량의 최대값을 찾지 못하는 경우
- s-a-t와 s-b-t 경로가 아닌 s-a-b-t경로를 선택한 경우, 최대 유량을 찾지 못하게 되는데 유량 상쇄 개념을 넣게 된다면 최대 유량을 찾는데 수월해진다.


■  **유량 상쇄**

- 새 유량을 보내는 것과 기존의 유량을 상쇄하는 것은 같은 연산.
- ( a , b ) = 1 이라고 생각하면, ( b, a ) = -1 이 되어 a와 b는 서로에게 유량을 보내 주는 것이 의미 없어진다.

![image](https://user-images.githubusercontent.com/102197100/165811706-fa9e3a2c-f686-4b4f-8f00-56e0fc73b557.PNG)

- a와 b의 간선의 합이 0이 되므로 위 그래프는 두 경로로 갈 수 있어 최대 유량이 1 이었던 왼쪽 경로에서 최대 유량이 2인 오른쪽 경로로 바꿀 수 있다.

